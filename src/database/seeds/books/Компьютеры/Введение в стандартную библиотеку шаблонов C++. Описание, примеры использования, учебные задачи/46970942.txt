Введение в стандартную библиотеку шаблонов C++. Описание, примеры использования, учебные задачи
Михаил Эдуардович Абрамян


Учебник состоит из трех основных разделов. Первый раздел содержит описание стандартной библиотеки шаблонов C++, во втором приводятся примеры ее применения, а третий представляет собой задачник из 300 учебных заданий, охватывающих все разделы стандартной библиотеки. При описании библиотеки учитываются нововведения стандарта С++11. В четвертом, дополнительном разделе дается обзор средств электронного задачника Programming Taskbook for STL, позволяющих выполнять учебные задания более быстро и эффективно.

Для студентов бакалавриата, обучающихся по направлению подготовки 02.03.02 «Фундаментальная информатика и информационные технологии».





М. Э. Абрамян

Введение в стандартную библиотеку шаблонов C++. Описание, примеры использования, учебные задачи





Предисловие


Книга, предлагаемая вашему вниманию, представляет собой практико-ориентированный учебник по стандартной библиотеке шаблонов языка C++. Для библиотеки шаблонов часто используется название STL (Standard Template Library), которое является неформальным, однако позволяет отличить ее от остальных частей стандартной библиотеки C++. Начиная с 1998 г. библиотека STL входит в стандарт C++ ISO/IEC 14882 (C++98); она содержит средства для создания и преобразования различных структур данных и использует технологию обобщенного программирования. Архитектура библиотеки STL базируется на трех основных компонентах: контейнерах, итераторах и алгоритмах. Контейнеры предназначены для хранения наборов объектов в памяти; STL включает две группы контейнеров: последовательные и ассоциативные, в каждую группу входят контейнеры с различными свойствами, что позволяет выбирать контейнер, наиболее подходящий для решения поставленной задачи. Итераторы обеспечивают унифицированные средства доступа к содержимому контейнера. Благодаря концепции итераторов, базирующейся на средствах обобщенного программирования, оказалось возможным реализовать универсальные алгоритмы – вычислительные процедуры, предназначенные для анализа и преобразования контейнеров. Один и тот же алгоритм может быть применен к любым контейнерам, обладающим требуемыми для этого алгоритма свойствами (точнее, имеющим итераторы того типа, который необходим для корректной работы алгоритма). Еще одной составной частью библиотеки STL являются функциональные объекты, представляющие собой обобщения функций и фигурирующие во многих алгоритмах. В пересмотренном стандарте C++ ISO/IEC 14882:2011 (C++11) библиотека STL была дополнена рядом новых возможностей.

Библиотека STL является одной из наиболее трудных для изучения частей стандартной библиотеки С++. Во-первых, это достаточно большая часть стандартной библиотеки: она включает 5 основных видов итераторов, а также их модификации, 7 основных и ряд дополнительных контейнеров, около 70 (в стандарте C++11 – около 90) алгоритмов, большинство из которых реализовано в нескольких вариантах, и большое число стандартных функциональных объектов. Во-вторых, архитектура библиотеки STL основана на шаблонах – весьма сложном разделе языка C++ [3]. Следует заметить, что особенности механизма шаблонов языка C++ затрудняют поиск и исправление ошибок, допущенных при использовании средств библиотеки STL (в частности, сообщения компилятора об ошибке нередко связываются с фрагментами стандартного программного кода, а не с теми операторами разрабатываемой программы, в которых фактически была допущена ошибка). В то же время библиотека STL относится к тем основным частям стандартной библиотеки, владение которыми является обязательным условием для квалифицированной разработки программ на языке C++.

По библиотеке STL имеется обширная учебная литература, в том числе и на русском языке. Можно отметить книги [2, 4, 6, 7], целиком посвященные STL, а также соответствующие разделы в известных учебниках [5, 8]. Однако очень немногие издания содержат наборы упражнений, позволяющие закрепить полученные знания (в частности, из перечисленных книг упражнения содержат лишь учебники универсального содержания [5, 8]). При этом предлагаемые упражнения не охватывают все возможности библиотеки и являются достаточно сложными, что затрудняет их использование при проведении лабораторных занятий. Настоящее издание призвано восполнить этот пробел. Помимо компактного, но в то же время достаточно подробного описания всех элементов стандартной библиотеки шаблонов, приведенного в разделе 1, а также примеров их применения (которым посвящен раздел 2), оно содержит набор из 300 задач по всем основным разделам стандартной библиотеки и, таким образом, позволяет не только ознакомиться с ее возможностями, но и освоить эту библиотеку на практике. Задачи разбиты на 7 групп; содержание групп, их особенности и формулировки всех задач приведены в разделе 3.

В описании основных компонентов библиотеки STL учитываются нововведения стандарта C++11. Задания ориентированы в основном на базовый вариант библиотеки STL, соответствующий стандарту C++98, однако при их выполнении вполне допустимо (и более удобно) использовать новые возможности, появившиеся в стандарте C++11.

Все задачи, приведенные в книге, входят в состав электронного задачника Programming Taskbook for STL (PT for STL), являющегося одним из дополнений универсального задачника по программированию Programming Taskbook. Задачник PT for STL может использоваться совместно со средами программирования Microsoft Visual Studio 2008, 2010, 2012, 2013, 2015, 2017 и Code::Blocks, начиная с версии 13. Он позволяет генерировать программы-заготовки для выбранных заданий, предоставляет программам наборы тестовых исходных данных, проверяет правильность полученных результатов, диагностирует различные виды ошибок и отображает на экране все данные, связанные с заданием. Все эти возможности существенно ускоряют выполнение заданий. Особенности применения задачника при выполнении заданий подробно описываются в разделе 2, а дополнительные средства задачника, упрощающие ввод, вывод и отладочную печать данных, – в разделе 4.

Получить дополнительную информацию об электронном задачнике Programming Taskbook и его дополнении Programming Taskbook for STL (а также других его дополнениях) и скачать их дистрибутивы можно на сайте электронного задачника – http://ptaskbook.com/.

Автор считает своим приятным долгом выразить искреннюю благодарность Денису Владимировичу Дуброву и Артему Михайловичу Пеленицыну, которые прочитали первый вариант рукописи и высказали много ценных замечаний.




Раздел 1. Описание библиотеки STL





1.1. Итераторы





1.1.1. Общее описание


В библиотеке STL используются пять основных видов итераторов:



• итераторы чтения;

• итераторы записи;

• однонаправленные итераторы;

• двунаправленные итераторы;

• итераторы произвольного доступа.


Для каждого вида итераторов определен набор операций, причем двумя операциями, доступными для всех видов итераторов, являются операция инкремента ++, которая передвигает итератор p на следующий элемент последовательности (++p и p++), и операция разыменования 


, возвращающая значение текущего элемента (


p и вариант p->m для доступа к члену m разыменованного объекта).

Операция разыменования имеет следующие особенности:



• в случае итераторов чтения операция 


не может использоваться для изменения элемента;

• в случае итераторов записи операция 


не может использоваться для получения значения элемента (выражение 


p можно использовать только в левой части присваивания);

• для прочих итераторов операция 


может использоваться как для получения значения элемента, так и для изменения этого значения.


Операции сравнения итераторов на равенство == и != реализованы для всех итераторов, кроме итераторов записи.

Для однонаправленных итераторов не определяются новые операции (по сравнению с итераторами чтения или записи).

Для двунаправленных итераторов в дополнение к операции инкремента ++ вводится операция декремента -– (также в двух видах: –p и p–).

Наконец, для итераторов произвольного доступа добавляются операция индексирования [ ], позволяющая сразу обратиться к элементу последовательности с требуемым индексом (p[i]), и операция смещения на указанное количество элементов, причем в оба направления (p + i и p – i). Имеется также операция разности двух итераторов, позволяющая определить расстояние между элементами, с которыми они связаны (p2 – p1).

Таким образом, набор операций для итераторов произвольного доступа аналогичен набору операций для обычных указателей.

Для итераторов, не являющихся итераторами произвольного доступа, также можно выполнять действия, связанные со смещением и определением расстояния, используя функции из заголовочного файла <iterator>:



• advance(p, n) – передвигает итератор p на n позиций вперед (n >= 0); для двунаправленного итератора можно использовать n < 0 для перемещения назад;

• distance(p1, p2) – возвращает расстояние между итераторами p1 и p2 (в предположении, что расстояние неотрицательно, т. е. что итератор p1 предшествует итератору p2 или совпадает с ним; для двунаправленных итераторов p2 может предшествовать итератору p1, в этом случае расстояние будет отрицательным).


Два итератора обычно используются для задания диапазона элементов, при этом предполагается, что первый итератор (first) указывает на начальный элемент диапазона, а второй итератор (last) указывает на позицию за конечным элементом диапазона (причем эта позиция может не быть связана с существующим элементом). Чтобы подчеркнуть отмеченные особенности для диапазонов, определяемых итераторами, они часто записываются в виде полуинтервала [first, last) (левая граница диапазона включается, правая – нет). Полуинтервал [first, first) не содержит ни одного элемента.

В качестве итераторов чтения и итераторов записи можно использовать итераторы всех остальных видов (однонаправленные, двунаправленные, произвольного доступа); следует лишь учитывать, что итераторы записи можно инкрементировать неограниченно, тогда как итераторы других видов всегда связываются с некоторым диапазоном допустимых элементов. В качестве однонаправленных итераторов можно использовать двунаправленные итераторы и итераторы произвольного доступа, а в качестве двунаправленных итераторов – итераторы произвольного доступа.

Для всех видов итераторов определены их модификации – константные итераторы, отличающиеся от обычных тем, что их разыменование дает константное значение.

Особыми итераторами являются итераторы потоков ввода–вывода (см. п. 1.1.2), обратные итераторы (см. п. 1.2.9) и итераторы вставки (см. п. 1.3.4).




1.1.2. Итераторы потоков ввода-вывода


Стандартные потоковые итераторы istream_iterator<T> и ostream_iterator<T> (шаблонные классы) определены в заголовочном файле <iterator>.

Имеются два варианта конструктора для итератора потокового чтения istream_iterator: вариант с параметром-потоком stream создает итератор для чтения из данного потока, вариант без параметров создает итератор, обозначающий конец потока (все итераторы, обозначающие конец потока, считаются равными друг другу и не равными никаким другим итераторам потокового чтения).

Ниже перечислены свойства потоковых итераторов чтения:



• тип T определяет тип элементов данных, которые считываются из потока;

• чтение элемента из потока выполняется в начальный момент работы с итератором, а затем при каждой операции инкремента ++;

• имеются два варианта операции ++: префиксный инкремент (++p) и постфиксный инкремент (p++);

• операция 


(и ее вариант ->) возвращает последнее прочитанное значение, причем эту операцию можно использовать неоднократно для получения того же самого значения;

• при достижении конца потока итератор становится равным итератору конца потока; последующие вызовы операции инкремента игнорируются, а в результате вызова операции 


всегда возвращается значение последнего прочитанного из потока элемента (если же с итератором был связан пустой поток, то результат операции 


не определен, хотя и не приводит к аварийному завершению программы).


Для итератора потоковой записи ostream_iterator<T> также определены два конструктора: первый конструктор содержит единственный параметр stream, задающий поток вывода, а второй конструктор дополнительно к параметру stream содержит второй параметр delim, задающий разделитель, который добавляется в поток вывода после каждого выведенного элемента (если параметр delim не указан, то между выводимыми элементами никакой разделитель не добавляется).

Ниже перечислены свойства потоковых итераторов записи:



• специальный конструктор для создания итератора конца потока вывода не предусмотрен;

• операции 


и ++ не выполняют никаких действий и просто возвращают сам итератор;

• операция присваивания p = выражение (где p – имя итератора записи) записывает значение выражения в поток вывода.





1.2. Контейнеры





1.2.1. Общее описание


Данный раздел посвящен контейнерам, входящим в стандартную библиотеку шаблонов C++. Подробно описываются те основные виды последовательных и ассоциативных контейнеров, с которыми связаны задания, приводимые в книге: это векторы (vector), деки (deque), списки (list), множества (set), мультимножества (multiset), отображения (map) и мультиотображения (multimap), а также текстовые строки (string), которые относят к псевдоконтейнерам. Другие виды контейнеров кратко описываются в п. 1.2.8: это контейнеры-адаптеры стек (stack), очередь (queue) и очередь с приоритетом (priority_queue), а также контейнеры, добавленные в библиотеку STL в стандарте C++11 (array, forward_list и ассоциативные контейнеры на базе хеш-функций). Все контейнеры определены в пространстве имен std.

В таблицах 1 и 2 перечислены характеристики основных видов последовательных и ассоциативных контейнеров.



Таблица 1

Последовательные контейнеры






Таблица 2

Ассоциативные контейнеры






В описаниях шаблонов контейнеров, приводимых в таблицах 1 и 2, и далее при описании конструкторов и функций-членов этих контейнеров (см. п. 1.2.2–1.2.6) не указывается дополнительный тип Alloc, который обычно устанавливается по умолчанию. Необязательные параметры заключаются в квадратные скобки, набранные полужирным шрифтом: [ ]. В частности, если в шаблоне ассоциативного контейнера не указывается операция сравнения Compare, то она считается равной less<Key>.

Контейнеры могут содержать данные только тех типов T, которые удовлятворяют некоторым естественным условиям (например, в стандарте C++98 требуется, чтобы для типа T был определен конструктор копирования и операция присваивания).

Все рассматриваемые последовательные контейнеры допускают вставку новых элементов в любую позицию и удаление элементов из любой позиции. Векторы оптимизированы для быстрого (за константное время) выполнения операций вставки и удаления, связанных с концом последовательности элементов (функции-члены push_back и pop_back), а деки – для операций, связанных как с началом, так и с концом последовательности (функции-члены push_back и pop_back, push_front и pop_front). В то же время, векторы обладают рядом особенностей, отсутствующих у деков; в частности, они имеют такую характеристику, как емкость, которая доступна и для чтения (функция-член capacity) и для изменения (функция-член reserve). Текстовые строки string обладают возможностями, аналогичными возможностям векторов с символьными элементами. Списки позволяют выполнять быструю вставку и удаление элементов для любой позиции, однако доступ к элементу списка по его номеру требует линейного времени (т. е. зависит от текущего размера списка). По этой причине для списков не реализована операция индексирования, а связанные со списками итераторы являются двунаправленными (а не итераторами произвольного доступа, как для всех остальных последовательных контейнеров). Еще одной особенностью списка является то, что операции вставки и удаления не влияют на корректность итераторов и ссылок, связанных с другими его элементами, в то время как для векторов и деков вставка или удаление элементов может приводить к тому, что некоторые (или все) итераторы и/или ссылки окажутся недействительными (подробности приведены в п. 1.2.7). Кроме того, для списков предусмотрен набор дополнительных функций-членов, отсутствующих у других последовательных контейнеров и представляющих собой оптимизированные реализации соответствующих алгоритмов (см. п. 1.2.5).

Все рассматриваемые ассоциативные контейнеры хранят последовательности своих элементов в отсортированном виде. Сортировка выполняется по ключу, причем для множеств и мультимножеств ключами выступают сами элементы (типа T), а в отображениях и мультиотображениях хранятся пары типа pair<Key, T>, первый компонент которых считается ключом (key), а второй – значением (value). По умолчанию порядок определяется операцией < для типа ключа Key, однако его можно явно указать в шаблоне контейнера в виде функционального объекта, реализующего бинарный предикат с параметрами типа Key и со свойствами операции сравнения «меньше». Мультимножества и мультиотображения, в отличие от множеств и отображений, позволяют хранить набор элементов с эквивалентными ключами (ключи считаются эквивалентными, если ни один из них не является меньшим, чем другой). Для отображения определена операция индексирования с дополнительными возможностями (см. п. 1.2.6). Вставка новых элементов в любой ассоциативный контейнер сохраняет его упорядоченность. И операция вставки, и операция удаления для ассоциативных контейнеров требует логарифмического времени, если для этих операций указывается параметр-ключ. За это же время выполняется и поиск элементов по ключу, для реализации которого в ассоциативных контейнерах предусмотрен целый набор функций-членов. Указанные свойства ассоциативных контейнеров делают их удобным механизмом для группировки и объединения наборов данных по ключу.

Поскольку контейнеры, перечисленные в таблицах 1 и 2, имеют много одинаковых функций-членов, все они далее рассматриваются совместно: в п. 1.2.2 перечисляются типы, связанные с контейнерами, и описываются варианты конструкторов, в п. 1.2.3 приводятся функции-члены, имеющиеся у всех контейнеров, в п. 1.2.4 – функции-члены последовательных контейнеров, в п. 1.2.5 – дополнительные функции-члены списков, в п. 1.2.6 – функции-члены ассоциативных контейнеров. В каждом пункте все функции-члены приводятся в алфавитном порядке их имен. Если некоторые функции-члены имеются не у всех рассматриваемых типов контейнеров, то это явно указывается; кроме того, специальным образом помечаются функции-члены, добавленные в стандарте C++11 (например, текст vector(C++11), string означает, что соответствующая функция-член доступна только для классов vector и string, причем для класса vector – только начиная со стандарта C++11). Если один из прежних вариантов функции-члена отсутствует в стандарте С++11, то он помечается текстом C++98.

Класс string имеет гораздо больше функций-членов, чем остальные контейнеры, однако в данном разделе приводятся только те из них, которые имеются также и у других последовательных контейнеров.

Если требуется одновременно упомянуть и множество, и мультимножество, то используется слово «(мульти)множество»; если требуется одновременно упомянуть и отображение, и мультиотображение, то используется слово «(мульти)отображение».

В последующих описаниях функций-членов некоторые переменные всегда связываются с данными фиксированного типа (этот тип определяется в самом контейнере – см. п. 1.2.2):



• n имеет тип size_type;

• k имеет тип key_type;

• x (а также x1, x2, …) имеет тип value_type;

• init_list имеет тип списка инициализации initializer_list<value_type> (элементы списка инициализации разделяются запятыми, сам список заключается в фигурные скобки);

• pos, hintpos, first и last (а также pos_lst, first_lst, last_lst) имеют тип итератора соответствующего контейнера (iterator).


Переменная other обозначает параметр, являющийся контейнером того же типа, что и контейнер, для которого вызывается функция-член. Переменные InIterFirst и InIterLast обозначают итераторы чтения, которые могут быть связаны с контейнером другого типа (при этом тип элементов контейнера должен совпадать с типом элементов контейнера, для которого вызывается функция-член).

Функции-члены begin, end, rbegin, rend, front, back, at, equal_range, find, lower_bound, upper_bound (а также data для векторов и operator[ ] для последовательных контейнеров) реализованы в двух вариантах: неконстантном и константном (например, iterator begin(…) и const_iterator begin(…) const); в дальнейшем это особо не оговаривается и константный вариант не приводится. В стандарте C++11 константные варианты функций-членов begin, end, rbegin, rend можно использовать с именами cbegin, cend, crbegin, crend соответственно.




1.2.2. Типы, определенные в контейнерах. Параметры конструкторов


Для доступа к указанным типам используется нотация ::, например vector<int>::iterator.








Типы итераторов, связанные с данным контейнером.








Типы ссылок на элементы данного контейнера.








Типы указателей на элементы данного контейнера.








Тип, используемый при указании размера контейнера.








Тип элементов контейнера (T для последовательных контейнеров, Key для (мульти)множеств, pair<const Key, T> для (мульти)отображений).








Тип Key (элементы-ключи для (мульти)множеств, ключи для (мульти)отображений).








Тип значений T для (мульти)отображений.








Тип функционального объекта, используемого при сравнении ключей типа key_type.








Тип функционального объекта, используемого при сравнении элементов типа value_type по ключу типа key_type.

Ниже приводятся варианты параметров для конструкторов контейнеров. Большинство вариантов может использоваться для всех видов рассматриваемых контейнеров; единственный особый вариант для последовательных контейнеров помечен соответствующим образом. Следует обратить внимание на вариант конструктора, появившийся в стандарте C++11 и использующий список инициализации.








Создает пустой контейнер. Для ассоциативных контейнеров можно дополнительно указать операцию сравнения comp (по умолчанию используется операция сравнения Compare(), взятая из шаблона).








Создает контейнер, содержащий элементы (типа value_type) из диапазона [InIterFirst, InIterLast). Для ассоциативных контейнеров можно дополнительно указать операцию сравнения comp (по умолчанию используется операция сравнения Compare(), взятая из шаблона). Для ассоциативных контейнеров вставляемые элементы не обязаны быть упорядоченными, однако если они упорядочены, то время их вставки ускоряется.








Создает копию контейнера other (тип контейнера other должен совпадать с типом создаваемого контейнера). В стандарте С++11 добавлен вариант конструктора с параметром other, обеспечивающий перемещение элементов контейнера other, если контейнер other является ссылкой на r-значение (r-value reference; для описания подобной ссылки используется двойной символ &&)








Создает последовательный контейнер, содержащий n копий значения x. Для строк string обязательными являются оба параметра. В стандарте С++11 вариант с одним параметром оптимизирован таким образом, чтобы избежать создания ненужных копий объектов T.








Конструктор, использующий список инициализации (initializer list). Перед списком может указываться символ =. Например, создать вектор с элементами 1, 2, 4 можно с помощью любого из следующих вариантов описания:









1.2.3. Функции-члены всех контейнеров







Удаляет все элементы контейнера и копирует в него все элементы контейнера other (тип контейнера other должен совпадать с типом преобразуемого контейнера). Возвращает полученный контейнер. В стандарте С++11 добавлен вариант операции =, обеспечивающий перемещение элементов контейнера other, если контейнер other является ссылкой на r-значение (r-value reference), а также вариант со списком инициализации init_list (см. описание последнего варианта конструктора в п. 1.2.2).








Возвращает итератор, указывающий на первый элемент контейнера.








Удаляет все элементы контейнера.








Возвращает true, если контейнер пуст, и false в противном случае.








Возвращает итератор, указывающий на позицию за последним элементом контейнера.








Возвращает максимально возможный размер контейнера.








Возвращает обратный итератор, связанный с последним элементом контейнера.








Возвращает обратный итератор, связанный с позицией перед первым элементом контейнера.








Возвращает текущий размер контейнера.








Меняет местами содержимое данного контейнера и контейнера other того же типа.




1.2.4. Функции-члены последовательных контейнеров







Удаляет все элементы контейнера и копирует в него новые данные (n копий значения x или элементы из диапазона [InIterFirst, InIterLast)). В стандарте C++11 добавлен вариант с параметром init_list – списком инициализации. Данная функция расширяет возможности, предоставляемые операцией копирования =.








Возвращает ссылку на элемент с индексом n (0 <= n < size()). Выход за границы не контролируется. Для типа string в случае n == size() возвращается символ с кодом 0.








Возвращает ссылку на элемент с индексом n (0 <= n < size()). Выход за границы приводит к возбуждению исключения out_of_range.








Возвращает ссылку на последний элемент контейнера. Для пустого контейнера поведение не определено.








Возвращает текущую емкость контейнера.








Возвращает указатель на внутренний массив, содержащий элементы вектора или символы строки. Для строк реализован только в константном варианте и возвращает константный указатель.








Вставляет в позицию pos контейнера новый элемент, создавая этот элемент «на месте» и используя при его конструировании параметры arg1, arg2, … . Позволяет избежать дополнительных операций копирования или перемещения, выполняемых при использовании функции-члена insert. Возвращает итератор, указывающий на вставленный элемент.








Добавляет в конец контейнера новый элемент, создавая этот элемент «на месте» и используя при его конструировании параметры arg1, arg2, … . Позволяет избежать дополнительных операций копирования или перемещения, выполняемых при использовании функции-члена push_back.








Добавляет в начало контейнера новый элемент, создавая этот элемент «на месте» и используя при его конструировании параметры arg1, arg2, … . Позволяет избежать дополнительных операций копирования или перемещения, выполняемых при использовании функции-члена push_front.








Удаляет элемент на позиции pos или все элементы в диапазоне [first, last) и возвращает итератор, указывающий на элемент, следующий за последним удаленным элементом (или итератор end(), если были удалены конечные элементы контейнера).








Возвращает ссылку на первый элемент контейнера. Для пустого контейнера поведение не определено.













Вставляет в контейнер новые данные, начиная с позиции pos (соответственно одно или n значений x, элементы из диапазона [InIterFirst, InIterLast) или элементы из списка инициализации init_list). Первый вариант функции-члена возвращает итератор, указывающий на вставленный элемент. Два последних варианта, добавленных в стандарт С++11 вместо третьего варианта, возвращают итератор, указывающий на первый вставленный элемент, или исходное значение pos, если диапазон или список инциализации являются пустыми.








Удаляет последний элемент. Для пустого контейнера поведение не определено.








Удаляет первый элемент. Для пустого контейнера поведение не определено.








Добавляет x в конец контейнера.








Добавляет x в начало контейнера.








Резервирует емкость размером не менее n.








Изменяет размер контейнера, делая его равным n. Если n > size(), то в конец контейнера добавляется требуемое число копий x. Если n < size(), то удаляется требуемое количество конечных элементов контейнера. В стандарте С++11 вариант с одним параметром оптимизирован таким образом, чтобы избежать создания ненужных копий объектов T.








Позволяет уменьшить размер памяти, выделенной для хранения элементов контейнера, однако не гарантирует, что память действительно будет уменьшена.




1.2.5. Дополнительные функции-члены класса list


Все дополнительные функции-члены класса list, кроме splice, представляют собой специальные реализации соответствующих алгоритмов, которые необходимо использовать вместо стандартных алгоритмов при обработке списков.








Выполняет операцию слияния текущего списка и списка lst того же типа (оба списка должны быть предварительно отсортированы). При слиянии элементы сравниваются с помощью операции < или предиката comp, если он явно указан (и эта же операция или предикат должны быть ранее использованы для сортировки списков). Слияние является устойчивым, т. е. относительный порядок следования элементов исходных списков не нарушается. Если «одинаковые» элементы присутствуют как в текущем списке, так и в списке lst, то элемент из lst помещается после элемента, уже присутствующего в текущем списке. В результате слияния список lst становится пустым. В стандарте С++11 добавлены варианты с параметром lst, являющимся ссылкой на r-значение (r-value reference).








Удаляет из списка, соответственно, все вхождения элемента x или все элементы, для которых предикат pred возвращает значение true.








Изменяет порядок элементов списка на обратный.








Выполняет сортировку списка, используя операцию < или предикат comp, если он явно указан. Сортировка является устойчивой, т. е. относительный порядок элементов с одинаковыми ключами сортировки не изменяется.








Перемещает элементы из списка lst в текущий список (элементы размещаются, начиная с позиции pos). Перемещаются, соответственно, все элементы списка lst, элемент списка lst, расположенный на позиции pos_lst, и элементы списка lst из диапазона [first_lst, last_lst) (если текущий список совпадает со списком lst, то итератор pos не должен входить в диапазон [first_lst, last_lst)). В стандарте С++11 добавлены варианты с параметром lst, являющимся ссылкой на r-значение (r-value reference).








Удаляет соседние «одинаковые» элементы списка, оставляя первый из набора «одинаковых» элементов. Для сравнения элементов используется операция == или предикат pred, если он явно указан.




1.2.6. Функции-члены ассоциативных контейнеров







Возвращает ссылку на значение, связанное с ключом k. Если ключ k отсутствует в контейнере, то в контейнер добавляется пара с ключом k и значением по умолчанию T(), и операция [ ] возвращает ссылку на это значение. Фактически данная операция возвращает следующее выражение: insert(make_pair(k, T())).first->second. В стандарте С++11 добавлен вариант с параметром k, являющимся ссылкой на r-значение (r-value reference).








Возвращает ссылку на значение, связанное с ключом k. Если ключ k отсутствует в контейнере, то возбуждается исключение out_of_range.








Возвращает число ключей со значением k. Для множества и отображения это либо 0, либо 1; для мультимножества и мультиотображения возвращаемое значение может быть больше 1.








Вставляет в контейнер новый элемент, создавая этот элемент «на месте» и используя при его конструировании параметры arg1, arg2, … . Позволяет избежать дополнительных операций копирования или перемещения, выполняемых при использовании функции-члена insert. Если элемент с указанным ключом уже имеется в контейнере, то в случае множества и отображения попытка вставки игнорируется. Возвращает итератор, указывающий на вставленный элемент, а также (в варианте для множества и отображения) логическое значение, определяющее, была ли произведена вставка. Если вставка не была произведена из-за того, что в контейнере (множестве или отображении) уже существует элемент с таким же ключом, то возвращается позиция уже имеющегося элемента с этим ключом.








Вставляет в контейнер новый элемент, создавая этот элемент «на месте» и используя при его конструировании параметры arg1, arg2, … . Позволяет избежать дополнительных операций копирования или перемещения, выполняемых при использовании функции-члена insert. Параметр hintpos является «подсказкой» для позиции вставки: элемент x вставляется максимально близко перед позицией hintpos. Возвращает итератор, указывающий на вставленный элемент (если элемент с указанным ключом уже имеется в контейнере, то в случае множества и отображения попытка вставки игнорируется и возвращается позиция уже имеющегося элемента с этим ключом).








Возвращает результат вызова функций lower_bound и upper_bound в виде пары итераторов: make_pair(lower_bound(k), upper_bound(k)).








Удаляет элемент (элементы) с ключом k, элемент в позиции pos или все элементы в диапазоне [first, last). В первом случае возвращает количество удаленных элементов (для множества и отображения это либо 0, либо 1). Два последних варианта, добавленных в стандарт С++11 вместо двух предыдущих вариантов, возвращают итератор, указывающий на элемент, следующий за последним удаленным элементом (или итератор end(), если были удалены конечные элементы контейнера).








Ищет ключ k и возвращает итератор, указывающий на соответствующий элемент контейнера, или end(), если ключ не найден. В случае мультимножества и мультиотображения итератор может указывать на любой из элементов с ключом k.













Вставляет в контейнер новые данные. Если данные с указанным ключом уже имеются в контейнере, то в случае множества и отображения попытка вставки игнорируется. Во всех вариантах, кроме двух последних, функция возвращает позицию вставленного элемента, а также (в первом варианте, имеющемся только у множества и отображения) логическое значение, определяющее, была ли произведена вставка. Если вставка не была произведена из-за того, что в контейнере (множестве или отображении) уже существует элемент с таким же ключом, то возвращается позиция уже имеющегося элемента с этим ключом. Параметр hintpos является «подсказкой» для позиции вставки: элемент x вставляется максимально близко к позиции hintpos (в стандарте C++11 уточняется, что вставка выполняется перед позицией hintpos). Вариант с параметрами InIterFirst, InIterLast обеспечивает вставку всех элементов из диапазона [InIterFirst, InIterLast); эти элементы не обязаны быть упорядоченными по ключу, однако если они упорядочены, то время их вставки уменьшается. Вариант с параметром init_list (списком инициализации) вставляет в контейнер все элементы из указанного списка; этот вариант добавлен в стандарте C++11.








Возвращает функциональный объект, обеспечивающий сравнение ключей.








Если в множестве или отображении присутствует элемент с ключом k, то возвращается его позиция (в случае мультимножества или мультиотображения возвращается позиция первого элемента с ключом k); если такого элемента нет, то возвращается позиция, куда будет вставлен такой элемент.








Если в множестве или отображении присутствует элемент с ключом k, то возвращается позиция элемента, следующего за ним (в случае мультимножества и мультиотображения возвращается позиция элемента, следующего за последним элементом с ключом k); если элемента с ключом k нет, то возвращается позиция, куда будет вставлен такой элемент.








Возвращает функциональный объект, обеспечивающий сравнение элементов контейнера по их ключам. В случае (мульти)множества совпадает с объектом key_compare, в случае (мульти)отображения выполняет сравнение пар pair<const Key, T> по их первому компоненту Key.




1.2.7. Вставка и удаление в последовательных контейнерах


Функция-член insert реализована во всех последовательных контейнерах в трех вариантах (в стандарте С++11 добавлен еще один вариант). Первый параметр во всех вариантах – итератор pos, определяющий позицию вставки. Новые данные вставляются, начиная с указанной позиции pos; все прежние элементы, начиная с позиции pos и далее, смещаются вправо (по направлению к концу контейнера). Варианты различаются параметрами, определяющими, что именно вставляется: это либо (1) один параметр x типа T (вставляется единственное значение x), либо (2) параметры n и x (вставляются n значений x), либо (3) два итератора чтения InIterFirst и InIterLast (вставляются все элементы из диапазона [InIterFirst, InIterLast)), либо (4, в стандарте C++11) список инициализации init_list. До появления стандарта C++11 только вариант (1) функции insert возвращал значение, этим значением являлся итератор, указывающий на вставленный элемент. В стандарте С++11 варианты (3) и (4) также возвращают значение – итератор, указывающий на первый вставленный элемент, или исходное значение pos, если диапазон или список инциализации являются пустыми. Параметр-итератор pos и возвращаемый итератор всегда прямые (обычные) итераторы; обратные итераторы в качестве pos использовать нельзя.

Имеются дополнительные функции-члены, связанные со вставкой: это push_back(x) – вставка одного элемента в конец контейнера (реализована для всех последовательных контейнеров) и push_front(x) – вставка одного элемента в начало контейнера (реализована для дека и списка). Эти функции не возвращают значения.

Функция-член erase реализована во всех последовательных контейнерах в двух вариантах: (1) с параметром-итератором pos, определяющим позицию удаляемого элемента, и с двумя параметрами-итераторами first и last, определяющими диапазон [first, last) удаляемых элементов. В обоих вариантах возвращается итератор, который указывает на элемент, расположенный за удаленным элементом (или удаленным диапазоном).

Имеются дополнительные функции-члены, связанные с удалением: это pop_back() – удаление последнего элемента из контейнера (реализована для всех последовательных контейнеров; поддержка для строк string добавлена в стандарте C++11), pop_front() – удаление первого элемента из контейнера (реализована для дека и списка), clear() – удаление всех элементов из контейнера (реализована для всех контейнеров). Эти функции не возвращают значения.

Альтернативой функциям insert и erase для списков list являются три варианта функции-члена splice, позволяющие перемещать отдельные элементы или их диапазоны между различными списками или между различными позициями одного списка. Все варианты функции splice начинаются с параметров pos (итератора, определяющего место вставки) и lst (списка-источника вставляемых данных). Если других параметров нет, то список-источник lst целиком вставляется в позицию pos списка-приемника; если имеется один дополнительный параметр-итератор pos_lst, то из списка-источника в список-приемник перемещается единственный элемент, связанный с итератором pos_lst; если имеются два дополнительных параметра first_lst и last_lst, то перемещается диапазон элементов [first_lst, last_lst). Все перемещаемые элементы удаляются из списка-источника.

При выполнении вставки и удаления важно знать, когда в результате выполнения этих действий итераторы и ссылки становятся недействительными (одновременно со ссылками становятся недействительными и указатели).

Вектор

Вставка:



• если в результате вставки выполняется перераспределение памяти (увеличивается емкость), то становятся недействительными все итераторы и ссылки;

• если перераспределения памяти не производится, то итераторы и ссылки до позиции вставки остаются корректными, а прочие – недействительными.


Удаление:



• все итераторы и ссылки до позиции удаления остаются корректными, а прочие – недействительными.


Дек

Вставка:



• все итераторы делаются недействительными;

• ссылки делаются недействительными при вставке в середину дека и остаются корректными при вставке в начало или конец дека.


Удаление:



• все итераторы делаются недействительными;

• ссылки на оставшиеся элементы делаются недействительными при удалении элементов из середины дека и остаются корректными при удалении начальных или конечных элементов дека.


Список

Вставка:



• все итераторы и ссылки остаются корректными.


Удаление:



• все итераторы и ссылки на оставшиеся элементы списка остаются корректными.





1.2.8. Контейнеры-адаптеры и контейнеры, добавленные в стандарт C++11


В данном пункте, как и в пунктах 1.2.2–1.2.7, посвященных основным видам контейнеров, при описании конструкторов и функций-членов контейнеров не указывается дополнительный тип Alloc, который обычно устанавливается по умолчанию. Все рассматриваемые в данном пункте контейнеры определены в пространстве имен std.

Начнем с описания контейнеров-адаптеров: стека (stack), очереди (queue) и очереди с приоритетом (priority_queue).

Особенностью контейнеров-адаптеров является то, что они основаны на одном из «настоящих» контейнеров, который хранится в качестве внутреннего контейнера (underlying container) с именем c – защищенного члена контейнера-адаптера. Для очереди с приоритетом используется еще один защищенный член – функциональный объект comp, используемый для сравнения элементов.

Реализация функций-членов контейнеров-адаптеров сводится к вызову соответствующих функций-членов «внутреннего» контейнера c. При этом набор средств, доступных для контейнеров-адаптеров, существенно сокращен по сравнению со средствами внутреннего контейнера. В частности, с контейнерами-адаптерами не связываются итераторы, что не позволяет их использовать совместно со стандартными алгоритмами.

В таблице 3 приводится описание шаблонов контейнеров-адаптеров.



Таблица 3

Контейнеры-адаптеры






Для всех контейнеров-адаптеров можно использовать конструктор без параметров и конструктор копии с параметром other того же типа, что и создаваемый адаптер; в стандарте С++11 добавлен конструктор перемещения, в котором параметр other является ссылкой на r-значение.

Кроме того, для стека и очереди можно использовать конструктор с явно указанным контейнером cont типа const Container& (в стандарте C++11 добавлен вариант с типом Container&&), содержимое которого копируется (или, соответственно, перемещается) во внутренний контейнер c адаптера.

Для очереди с приоритетом предусмотрены также конструкторы со следующими параметрами (в квадратных скобках, как обычно, указаны необязательные параметры):








Здесь параметр comp имеет тип const Compare& и определяет операцию сравнения для очереди с приоритетом, параметр cont имеет тип const Container& или Container&& (C++11) и определяет начальное содержимое, которое копируется или, соответственно, перемещается во внутренний контейнер c адаптера. При наличии параметров-итераторов чтения first и last после первоначального заполнения внутреннего контейнера с помощью параметра cont (или, по умолчанию, создания пустого внутреннего контейнера) для него вызывается функция-член c.insert(c.end(), first, last). На завершающем этапе формирования очереди с приоритетом с использованием данных вариантов конструктора для ее внутреннего контейнера вызывается алгоритм make_heap(c.begin(), c.end(), comp).

Для всех контейнеров-адаптеров определена операция =, обеспечивающая копирование (а в стандарте C++11 и перемещение) элементов из одного адаптера в другой того же типа.

Кроме того, для всех контейнеров-адаптеров (как и для всех других контейнеров) определены функции-члены bool empty() const и size_type size() const (выполнение которых сводится к вызову одноименных функций-членов внутренних контейнеров: c.empty() и c.size()), а также функция-член void swap(other), обеспечивающая обмен содержимым между двумя адаптерами одинакового типа (для этого выполняется вызов алгоритма swap(c, other.c), а в случае очереди с приоритетом дополнительно вызывается алгоритм swap(comp, other.comp)).

Для доступа к элементам контейнеров-адаптеров предусмотрены следующие функции-члены:



• стек: reference top() – доступ к верхнему элементу стека (возвращает c.back());

• очередь: reference front() – доступ к начальному элементу очереди (возвращает c.front()) и reference back() – доступ к конечному элементу очереди (возвращает c.back());

• очередь с приоритетом: reference front() – доступ к наибольшему элементу очереди (возвращает c.front()).


Контейнеры-адаптеры реализуют ограниченный набор действий. Стек позволяет добавлять новый элемент в вершину, получать значение верхнего элемента и удалять верхний элемент. Очередь позволяет добавлять новый элемент в конец, получать значение начального и конечного элемента и удалять начальный элемент. Очередь с приоритетом позволяет добавлять новый элемент, получать значение наибольшего элемента и удалять наибольший элемент.

Во всех контейнерах-адаптерах используются одинаковые имена для функций-членов, связанных с добавлением и удалением элементов. Эти функции-члены описаны в таблице 4.



Таблица 4

Вставка и удаление для контейнеров-адаптеров






Теперь кратко опишем те новые виды контейнеров, которые появились в стандарте C++11.

Контейнер array является контейнерным аналогом массива фиксированного размера. Его шаблон имеет вид: array<T, N>, где T – это тип элементов, а N – число, задающее размер контейнера. Данный контейнер определен в заголовочном файле <array>. Помимо конструктора без параметров контейнер array можно инициализировать с помощью списка инициализации. Все, кроме одной, функции-члены контейнера array аналогичны по своему назначению одноименным функциям-членам контейнера vector (можно сказать, что array – это контейнер vector без возможности вставки и удаления элементов). Перечислим эти функции-члены:



• функции, описанные в п. 1.2.3: begin и его константный вариант cbegin, empty, end и его константный вариант cend, max_size, rbegin и его константный вариант crbegin, rend и его константный вариант crend, size, swap;

• функции, описанные в п. 1.2.4: operator[], at, back, data, front.


Единственная функция-член, имеющаяся в контейнере array и при этом отсутствующая в контейнере vector, – это функция void fill(value), позволяющая заполнить существующий контейнер array одинаковыми значениями value.

Контейнер forward_list является контейнерной реализацией односвязного списка (в отличие от контейнера list, реализующего двусвязный список). Данный контейнер требует меньше памяти для хранения своих элементов, но при этом обладает и более ограниченным по сравнению со списком list набором возможностей. Его шаблон имеет вид: forward_list<T>, где T – тип элементов списка. Контейнер определен в заголовочном файле <forward_list>. Контейнер forward_list имеет те же варианты конструктора и операции =, что и контейнер list.

Перечислим функции-члены, которые имеются у обеих реализаций списков – как list, так и forward_list – и выполняются аналогичным образом:



• функции, описанные в п. 1.2.3: begin и его константный вариант cbegin, clear, empty, end и его константный вариант cend, max_size, swap;

• функции, описанные в п. 1.2.4: assign, emplace_front, front, pop_front, push_front, resize;

• функции, описанные в п. 1.2.5: merge, remove, remove_if, reverse, sort, unique.


Обратите внимание на то, что у списка forward_list отсутствуют средства быстрого доступа к его конечному элементу, а также обратные итераторы и функция-член size.

Функции-члены, связанные со вставкой и удалением элементов списка forward_list, отличаются от аналогичных функций списка list тем, что в качестве параметра pos указывается не позиция вставляемого или удаляемого элемента, а позиция, предшествующая позиции вставляемого или удаляемого элемента (что обусловлено односвязностью списка forward_list). По этой причине все функции-члены, связанные со вставкой и удалением, снабжены в классе forward_list суффиксом «after»: insert_after, emplace_after, erase_after, splice_after. Назначение этих функций и смысл их параметров те же, что и для аналогичных функций-членов контейнера list без суффикса _after: insert, emplace, erase (см. п. 1.2.4) и splice (см. п. 1.3.5). Исключение составляет параметр pos, указывающий, как было отмечено выше, позицию, предшествующую позиции вставляемого или удаляемого элемента, а также параметр first для функции erase_after(first, last) и параметры pos_lst и first_lst для функций splice_after(pos, lst, pos_lst) и splice_after(pos, lst, first_lst, last_lst):



• функция erase_after(first, last) удаляет элементы в диапазоне (first, last) (элемент first не удаляется, в чем состоит отличие от реализации функции-члена erase(first, last) в других последовательных контейнерах – см. п. 1.2.4);

• функция splice_after(pos, lst, pos_lst) перемещает из списка lst (типа forward_list) в текущий список элемент, следующий за элементом в позиции pos_lst (и помещает его в позицию, следующую за позицией pos), а функция splice_after(pos, lst, first_lst, last_lst) перемещает в позицию, следующую за позицией pos, элементы списка lst, расположенные в диапазоне (first_lst, last_lst) (элемент first_lst в диапазон не включается). Это отличается от поведения функций-членов splice контейнера list с аналогичным набором параметров (см. п. 1.2.5).


Контейнер forward_list содержит также функции-члены before_begin и cbefore_begin, которые возвращают обычный и константный итератор, указывающий на позицию, предшествующую первому элементу контейнера. Эти итераторы позволяют использовать функции insert_after, emplace_after, splice_after и erase_after для вставки новых данных в начало контейнера forward_list и удаления начальной части его элементов.

Неупорядоченные ассоциативные контейнеры unordered_set, unordered_multiset, unordered_map и unordered_multimap обеспечивают ту же функциональность, что и стандартные упорядоченные ассоциативные контейнеры set, multiset, map и multimap (см. п. 1.2.1, 1.2.2, 1.2.6), однако для поиска по ключу в них используются хеш-функции (hash functions), генерирующие хеш-коды ключей, а также функции, сравнивающие ключи на равенство. Все элементы, ключи которых возвращают одинаковый хеш-код, помещаются в одну ячейку (bucket) неупорядоченного ассоциативного контейнера (число ячеек для контейнера может либо устанавливаться по умолчанию, либо указываться в его шаблоне). При поиске элемента по ключу вначале вычисляется хеш-код ключа, определяющий ячейку, которая может содержать элемент с данным ключом. Если эта ячейка содержит несколько элементов, то элемент с нужным ключом ищется в ней обычным перебором. Высокая скорость в подобном механизме поиска обеспечивается за счет того, что для каждого ключа можно быстро определить его хеш-код, позволяющий сразу обратиться к нужной ячейке, которая, как правило, содержит небольшое число элементов.

Таким образом, поиск по ключу в неупорядоченных ассоциативных контейнерах выполняется с помощью двух видов операций сравнения на равенство, определяемых в шаблоне контейнера: это операция сравнения хеш-кодов, вычисленных хеш-функцией, и операция сравнения на равенство самих ключей (выполняемая при переборе элементов в пределах одной ячейки). Это отличает неупорядоченные контейнеры от упорядоченных, в которых ключи сравниваются тем или иным вариантом операции <.

Неупорядоченные ассоциативные контейнеры содержат практически все средства, имеющиеся у упорядоченных контейнеров (см. п. 1.2.2 и 1.2.6); отсутствуют лишь функции для работы с обратными итераторами, а также функции lower_bound и upper_bound (хотя функция-член equal_range имеется). Кроме того, вместо функций key_comp и value_comp у неупорядоченных контейнеров предусмотрены функции-члены hash_function (возвращает хеш-функцию), и key_eq (возвращает функцию для сравнения ключей на равенство). Разумеется, при переборе элементов неупорядоченных ассоциативных контейнеров не гарантируется, что они будут располагаться по возрастанию ключей.

Неупорядоченные контейнеры включают также следующие функции-члены для работы с ячейками:



• max_bucket_count() возвращает максимальное количество ячеек, которое можно выделить для данного контейнера;

• bucket_count() возвращает количество ячеек, выделенных для данного контейнера;

• bucket(key) возвращает индекс ячейки, содержащей элементы с ключом key;

• bucket_size(n) возвращает размер ячейки с указанным индексом n;

• begin(n), end(n) и cbegin(n), cend(n) возвращают итераторы для перебора всех элементов, входящих в ячейку с индексом n.


Наконец, еще одна группа функций-членов предназначена для оптимизации размещения данных в неупорядоченных контейнерах:



• load_factor() возвращает среднее число элементов к ячейке (число типа float, равное size()/bucket_count());

• max_load_factor позволяет определить (функция без параметров, возвращающая результат типа float) и изменить (void-функция с параметром типа float) максимальное среднее число элементов в ячейке; контейнер автоматически увеличивает количество ячеек, если значение load_factor() превысит указанное максимальное значение;

• rehash(count) позволяет явно изменить количество ячеек; в результате новое значение bucket_count() будет больше или равно count, а также больше size()/max_load_factor();

• reserve(n) настраивает контейнер таким образом, чтобы его размер можно было увеличивать до n элементов без автоматического увеличения количества ячеек.





1.2.9. Дополнение: обратные итераторы


Получить обратный итератор r можно из обычного (прямого) итератора p явным приведением типа, например:








Имеется функция-член rbegin(), которая возвращает приведенный к типу обратного итератора итератор end(), и функция-член rend(), возвращающая приведенный к типу обратного итератора итератор begin().

Операции инкремента и декремента прямого и обратного оператора взаимно обратны: r++ перемещает итератор в том же направлении, что и p–, а r– – в том же направлении, что и p++.

Для операции разыменования 


выполняется следующее базовое соотношение: если r может быть получен из p, то 


r равно 


(p – 1).

Функция-член base() обратного итератора возвращает прямой итератор, который можно было бы использовать для получения данного обратного итератора явным приведением типа: если r может быть получен из p, то r.base() == p. Или, иначе говоря, ((reverse_iterator)p).base == p.

Примеры

В следующем примере рассматривается последовательный контейнер cont с исходными элементами 1, 2, 3, 4, 5. Итераторы p2, p3, p4, p5 связаны с элементами 2, 3, 4, 5. Обратные итераторы r2, r3, r4, r5 определены следующим образом (rev – псевдоним типа обратного итератора для cont):








Значения разыменованных итераторов для исходного контейнера:








После выполнения оператора








значения разыменованных итераторов будут следующими («


» означает, что попытка разыменования приводит к непредсказуемым результатам):








Теперь повторно инициализируем итераторы p4 и r4








и выполним операторы








В результате значения разыменованных итераторов изменятся следующим образом:








Анализ полученных результатов полностью соответствует ранее описанным правилам использования функций insert и erase, а также правилам, связанным с корректностью итераторов. Имеется лишь одно не вполне очевидное обстоятельство, касающееся того, что происходит с обратными итераторами списка, значения которых были связаны с удаляемым элементом (r4) и с элементом, предшествующим удаляемому (r3).

Итератор r3 становится недействительным, что является вполне естественным, так как уничтожается тот элемент, на который указывал итератор r3.base().

В случае итератора r4 ситуация интереснее. Несмотря на то, что значение, которое он возвращал, пропало, сам этот итератор сохранился, поскольку сохранился связанный с ним прямой итератор r4.base() (и, хотя это не отражено в приведенных данных, после выполнения операции удаления значение r4.base() не изменилось). Однако, поскольку после удаления элемента 3 элементом, предшествующим «базовому» элементу, связанному с итератором r4.base(), оказался элемент 2, именно его значение возвращается при разыменовании обратного итератора r4. Таким образом, перед удалением элемента 3 значение итератора r4 было равно 3, а после его удаления значение становится равным предшествующему значению (т. е. 2). При вставке элемента 3 перед элементом 4 базовый элемент для обратного итератора r4 не изменился (он по-прежнему равен p4), но, поскольку теперь перед ним находится элемент 3, именно это значение (3) возвращается разыменованным итератором r4.




1.3. Алгоритмы





1.3.1. Общее описание


Данный раздел содержит описание всех алгоритмов стандартной библиотеки шаблонов, включенных в стандарт C++11. Новые алгоритмы, появившиеся в этом стандарте, помечены текстом C++11. Алгоритм random_shuffle, который объявлен в стандарте C++11 устаревшим, помечен текстом deprecated. Алгоритмы, определенные в заголовочном файле <algorithm>, описаны в п. 1.3.3, алгоритмы, определенные в заголовочном файле <numeric>, – в п. 1.3.4. В каждом пункте алгоритмы располагаются в алфавитном порядке своих имен.

Все алгоритмы определены в пространстве имен std. В таблице 5 алгоритмы сгруппированы в соответствии со способом их применения.



Таблица 5

Алгоритмы STL по категориям












1.3.2. Соглашения об именовании параметров


В качестве типов для параметров-итераторов first, last, result, result_last (возможно, дополненных номерами 1 или 2) указываются:



• InIter – итератор чтения (input);

• OutIter – итератор записи (output);

• FwdIter – однонаправленный итератор (forward);

• BidiIter – двунаправленный итератор (bidirectional);

• RandIter – итератор произвольного доступа (random).


В качестве типа значения для входных последовательностей указывается T; если выходная последовательность может иметь тип элементов, отличный от T, то для него используется имя TRes. Итераторы из диапазонов [first, last), [first1, last1), [first2, last2) обозначаются с помощью переменных p, p1, p2 соответственно.

Для типов функциональных объектов в описаниях алгоритмов используются следующие имена:



• UnaryOp – унарная операция (функциональный объект с операцией (), имеющей один параметр типа T; при этом тип возвращаемого значения может отличаться от типа T);

• BinaryOp – бинарная операция (функциональный объект с операцией (), имеющей два параметра, как правило, одинакового типа T; тип возвращаемого значения может отличаться от типа T); если параметры бинарной операции могут иметь различные типы, то об этом явно говорится в описании соответствующего алгоритма;

• Predicate – унарный предикат (унарная операция, возвращающая логическое значение);

• BinaryPredicate – бинарный предикат (бинарная операция с параметрами типа T, возвращающая логическое значение);

• Compare – бинарный предикат, предназначенный для сравнения элементов (аналог операции <);

• Generator – генератор последовательности (функциональный объект с операцией (), не имеющей параметров и возвращающей значение типа TRes);

• RandomGenerator – генератор случайных целых чисел, равномерно распределенных в диапазоне [0, n).


Во всех алгоритмах, связанных с копированием или перемещением данных, предполагается, что в результирующей последовательности зарезервировано достаточно места для размещения всех получаемых элементов.

Всюду при указании сложности алгоритма под N понимается разность итераторов distance(first, last) (если N имеет индекс, то подразумевается, что итераторы имеют такой же номер, например N


= distance(first1, last1)). Если сложность алгоритма является постоянной, т. е. не зависит от размера обрабатываемой последовательности, то она не указывается.




1.3.3. Алгоритмы общего назначения


Алгоритмы, описываемые в данном пункте, определены в заголовочном файле <algorithm>.








Находит первую пару соседних элементов из диапазона [first, last), которые равны (или, при наличии предиката pred(


p, 


(p + 1)), для которых данный предикат возвращает true). Возвращает итератор, связанный с первым элементом найденной пары, или last, если пара не найдена.

Сложность линейная (не более N + 1 вызовов pred).








Возвращает true, если все элементы диапазона [first, last) удовлетворяют предикату pred. В случае пустого диапазона также возвращается true.

Сложность линейная (не более N вызовов pred).








Возвращает true, если хотя бы один элемент диапазона [first, last) удовлетворяет предикату pred. В случае пустого диапазона возвращается false.

Сложность линейная (не более N вызовов pred).








Использует двоичный поиск для проверки того, содержится ли в диапазоне [first, last) значение value (если значение найдено, то возвращает true, иначе false). Содержимое диапазона должно быть предварительно отсортировано в соответствии с порядком, задаваемым предикатом comp(


p1, 


p2) или (по умолчанию) операцией <.

Сложность логарифмическая (не более log N + 2 сравнений).








Копирует элементы из [first, last) в диапазон, начинающийся с result, и возвращает позицию за последним скопированным элементом в полученном диапазоне. Итератор result не может находиться в исходном диапазоне [first, last), но другие части выходного диапазона могут накладываться на исходный диапазон. Таким образом, данный алгоритм можно применять для «копирования влево», т. е. копирования в ситуации, когда левая граница выходного диапазона находится слева от исходного диапазона.

Сложность линейная (N присваиваний).








Выполняет те же действия, что и copy, но перебирает исходные данные в обратном порядке: от элемента, предшествующего last, до first. Итератор result_last должен указывать на элемент, следующий за концом выходной последовательности; возвращаемое значение – это итератор, указывающий на первый элемент выходной последовательности. Итератор result_last не может находиться в диапазоне (first, last] (обратите внимание на границы этого диапазона), но другие части выходного диапазона могут накладываться на исходный диапазон. Таким образом, данный алгоритм можно применять для «копирования вправо», т. е. копирования в ситуации, когда правая граница выходного диапазона находится справа от исходного диапазона.

Сложность линейная (N присваиваний).








Копирует в диапазон, начинающийся с result, все элементы диапазона [first, last), для которых pred возвращает true. Возвращает позицию за последним скопированным элементом в полученном диапазоне. Относительный порядок элементов в полученном диапазоне сохраняется. Исходный и результирующий диапазоны не должны перекрываться.

Сложность линейная (N сравнений).








Копирует в диапазон, начинающийся с result, n элементов диапазона, начинающегося с first.

Сложность линейная (n присваиваний).








Возвращает количество элементов в диапазоне [first, last), которые равны значению value.

Сложность линейная (N сравнений).








Возвращает количество элементов в диапазоне [first, last), для которых выражение pred(


p) равно true.

Сложность линейная (N вызовов pred).








Возвращает true, если два диапазона содержат одни и те же элементы в одинаковом порядке. Первый диапазон – [first1, last1), второй начинается с first2 и имеет такую же длину; диапазоны могут перекрываться. Для сравнения используется предикат pred(


p1, 


p2) или (по умолчанию) операция ==.

Сложность линейная (не более N


сравнений).








Проверяет, имеется ли в диапазоне [first, last) значение value, и возвращает пару итераторов, которые указывают на начало диапазона, содержащего value, и на элемент за концом этого диапазона (если значение не найдено, то оба итератора указывают на позицию в диапазоне, в которую можно вставить value, не нарушая порядка сортировки). Содержимое диапазона должно быть предварительно отсортировано в соответствии с порядком, задаваемым предикатом comp(


p1, 


p2) или (по умолчанию) операцией <.

Сложность логарифмическая (не более 2


log N + 1 сравнений).








Заполняет выходной диапазон [first, last) значениями value.

Сложность линейная (N присваиваний).








Заполняет выходной диапазон из n элементов, начиная с first, значениями value.

Сложность линейная (n присваиваний).








Возвращает итератор, указывающий на первое вхождение элемента value в диапазоне [first, last), или last, если элемент value отсутствует. Для сравнения элементов используется операция ==.

Сложность линейная (не более N сравнений).








Находит последнюю (самую правую) подпоследовательность [first2, last2) в диапазоне [first1, last1). Возвращает итератор, который указывает на начало найденной подпоследовательности, или last1, если подпоследовательность не найдена. Для сравнения элементов используется предикат pred(


p1, 


p2) или (по умолчанию) операция ==.

Сложность линейная (не более N





N


сравнений).








Находит первое вхождение любого элемента подпоследовательности [first2, last2) в диапазон [first1, last1); возвращает итератор, который указывает на найденный элемент, или last1, если элемент не найден. Для сравнения элементов используется предикат pred(


p1, 


p2) или (по умолчанию) операция ==.

Сложность линейная (не более N





N


сравнений).








Возвращает итератор, указывающий для диапазона [first, last) на первое вхождение элемента, для которого выражение pred(


p) возвращает true; если требуемые элементы отсутствуют, то возвращает last.

Сложность линейная (не более N вызовов pred).








Возвращает итератор, указывающий для диапазона [first, last) на первое вхождение элемента, для которого выражение pred(


p) возвращает false; если требуемые элементы отсутствуют, то возвращает last.

Сложность линейная (не более N вызовов pred).








Вызывает функциональный объект f (как f(


p)) для всех элементов из диапазона [first, last) и возвращает этот же функциональный объект.

Сложность линейная (N вызовов f).








Заполняет диапазон [first, last), последовательно присваивая элементам диапазона результат вызова функционального объекта gen (как gen()).

Сложность линейная (N вызовов gen).








Заполняет последовательность, начинающуюся с позиции first, n элементами, полученными в результате вызова функционального объекта gen (как gen()).

Сложность линейная (n вызовов gen).








Возвращает true, если все элементы предварительно отсортированной последовательности [first2, last2) содержатся в предварительно отсортированной последовательности [first1, last1), и false в противном случае (фактически ищется вхождение подпоследовательности [first2, last2) в диапазон [first1, last1)). Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность линейная (не более 2


(N


+ N


) – 1 сравнений).








Выполняет слияние двух предварительно отсортированных частей [first, middle) и [middle, last) последовательности на месте, в результате чего создается единый отсортированный диапазон [first, last). Слияние является устойчивым; кроме того, в полученном диапазоне равные элементы из первого диапазона будут располагаться перед равными им элементами из второго диапазона. Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность линейная (N + 1 сравнений) или (при нехватке памяти) N


log N сравнений.








Возвращает true, если диапазон [first, last) представляет собой кучу (см. алгоритм make_heap). Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность линейная (не более N сравнений).








Определяет наибольший диапазон в пределах исходного диапазона [first, last), который начинается с first и представляет собой кучу (см. алгоритм make_heap). Возвращает позицию за концом найденного диапазона. Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность линейная (не более N сравнений).








Возвращает true, если в диапазоне [first, last) все элементы, удовлетворяющие предикату pred, расположены перед всеми элементами, которые предикату не удовлетворяют. В случае пустого диапазона также возвращается true.

Сложность линейная (не более N вызовов pred).








Возвращает true, если диапазон [first1, last1) представляет собой перестановку элементов диапазона, который начинается с first2 и имеет такую же длину. Для сравнения используется предикат pred(


p1, 


p2) или (по умолчанию) операция ==.

Сложность: не более N


N вызовов pred (ровно N вызовов в случае, если элементы первого диапазона совпадают с соответствующими элементами второго диапазона).








Возвращает true, если диапазон [first, last) представляет собой отсортированную последовательность. Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность линейная (не более N сравнений).








Определяет наибольший диапазон в пределах исходного диапазона [first, last), который начинается с first и представляет собой отсортированную последовательность. Возвращает позицию за концом найденного диапазона. Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность линейная (не более N сравнений).








Меняет местами значения, на которые указывают итераторы a и b.








Возвращает true, если последовательность [first1, last1) «меньше» (в лексикографическом смысле), чем последовательность [first2, last2), и false в противном случае (в частности, если последовательности равны, то возвращается false, а если первая последовательность является собственным префиксом второй, то возвращается true). Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность линейная (не более min{N


, N


} сравнений).








Проверяет, содержится ли в диапазоне [first, last) значение value, и возвращает итератор, который указывает на первое вхождение value (если значение не найдено, то итератор указывает на позицию в диапазоне, в которую можно вставить value, не нарушая порядка сортировки). Содержимое диапазона должно быть предварительно отсортировано в соответствии с порядком, задаваемым предикатом comp(


p1, 


p2) или (по умолчанию) операцией <.

Сложность логарифмическая (не более log N + 1 сравнений).








Переупорядочивает элементы диапазона [first, last), получая из него кучу (т. е. очередь с приоритетом, для которой первый элемент всегда больше остальных, а добавление нового элемента или удаление первого элемента может быть произведено за логарифмическое время, и результат тоже будет кучей). Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность линейная (не более 3


N сравнений).








Возвращает большее из значений a и b (при их равенстве возвращается a). Для сравнения значений используется предикат comp(a, b) или (по умолчанию) операция <.








Возвращает позицию первого наибольшего элемента в диапазоне [first, last). В случае пустого диапазона возвращает last. Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность линейная (max{N – 1, 0} сравнений).








Выполняет слияние двух предварительно отсортированных диапазонов [first1, last1) и [first2, last2) и копирование результата в последовательность, начиная с result (в выходной последовательности должно быть достаточно места для полученного набора данных). Возвращает выходной итератор, указывающий на позицию за концом добавленного набора данных. Выходной диапазон не должен накладываться ни на один из исходных диапазонов. Слияние является устойчивым; кроме того, в полученном диапазоне равные элементы из первого диапазона будут располагаться перед равными им элементами из второго диапазона. Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность линейная (не более N


+ N


– 1 сравнений).








Возвращает меньшее из значений a и b (при их равенстве возвращается a). Для сравнения значений используется предикат comp(a, b) или (по умолчанию) операция <.








Возвращает позицию первого наименьшего элемента в диапазоне [first, last). В случае пустого диапазона возвращает last. Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность линейная (max{N – 1, 0} сравнений).








Возвращает пару, содержащую меньшее и большее из значений a и b (при их равенстве возвращается пара (a, b)). Для сравнения значений используется предикат comp(a, b) или (по умолчанию) операция <.








Возвращает пару, содержащую позиции первого наименьшего и последнего наибольшего элемента в диапазоне [first, last). В случае пустого диапазона возвращает пару (last, last). Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность линейная (не более max{floor(3/2


(N – 1)), 0} сравнений).








Выполняет попарное сравнение элементов из диапазона [first1, last1) и диапазона, начинающегося с first2 и имеющего длину, не меньшую, чем длина первого диапазона. Возвращает первую пару различных элементов (или, если все элементы первого диапазона совпадают с соответствующими элементами второго диапазона, пару из итератора last1 и соответствующего итератора для второго диапазона). Для сравнения элементов используется предикат pred(


p1, 


p2) или (по умолчанию) операция ==.

Сложность линейная (не более N


сравнений).








Перемещает элементы из [first, last) в диапазон, начинающийся с result, и возвращает позицию за последним перемещенным элементом в полученном диапазоне. Итератор result не может находиться в исходном диапазоне [first, last). После выполнения этого алгоритма диапазон [first, last) будет попрежнему содержать элементы того же типа, но их значения могут отличаться от исходных.

Сложность линейная (N присваиваний).








Выполняет те же действия, что и move, но перебирает исходные данные в обратном порядке: от элемента, предшествующего last, до first. Итератор result_last должен указывать на элемент, следующий за концом формируемой выходной последовательности; возвращаемое значение – это итератор, указывающий на первый элемент выходной последовательности. Итератор result_last не может находиться в диапазоне (first, last] (обратите внимание на границы этого диапазона).

Сложность линейная (N присваиваний).








Переупорядочивает содержимое диапазона [first, last), создавая следующую перестановку из набора лексикографически упорядоченных перестановок элементов данного диапазона. Возвращает true, если перестановка была создана успешно, или false, если исходный диапазон представлял собой последнюю (в лексикографическом порядке) перестановку; в этом последнем случае генерируется первая в лексикографическом порядке перестановка (в которой все элементы расположены в порядке возрастания). Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность линейная (не более N/2 перемещений).








Возвращает true, если ни один из элементов диапазона [first, last) не удовлетворяет предикату pred. В случае пустого диапазона также возвращается true.

Сложность линейная (не более N вызовов pred).








Переупорядочивает диапазон [first, last) таким образом, чтобы в позиции nth размещался элемент, который стоял бы на этом месте в случае, если бы весь диапазон был отсортирован. Кроме того, в результате выполнения данного алгоритма все элементы в диапазоне [first, nth) не будут превосходить элементы из диапазона [nth, last). Алгоритм не является устойчивым: если имеется несколько элементов, которые при сортировке могли бы оказаться на позиции nth, то нельзя сказать, какой из них будет перемещен на эту позицию. Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность в среднем линейная (около N сравнений).








Частично сортирует элементы диапазона [first, last), размещая отсортированные элементы в диапазоне [first, middle). Оставшиеся элементы никак не упорядочиваются. Алгоритм не является устойчивым. Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность: примерно N


log(middle – first) сравнений.








Частично сортирует элементы из диапазона [first1, last1) и копирует отсортированную часть в диапазон [first2, last2). Размер сортируемой части определяется размером второго диапазона: если он меньше первого, то сортируется часть первого диапазона, если он больше или равен размеру первого диапазона, то сортируется весь первый диапазон.

Возвращается итератор второго диапазона, указывающий на позицию за концом отсортированного набора данных, добавленного из первого диапазона. Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность: примерно N





log(min{N


, N


}) сравнений.








Меняет местами элементы диапазона [first, last) так, чтобы все элементы, удовлетворяющие предикату pred, были расположены перед теми, которые ему не удовлетворяют. Относительный порядок следования элементов не сохраняется. Алгоритм возвращает итератор, указывающий на первый элемент, для которого pred возвращает false (или итератор last, если таких элементов нет).

Сложность линейная (N вызовов pred и не более N/2 перемещений элементов).








Копирует элементы из диапазона [first, last) в два выходных диапазона: элементы, удовлетворяющие предикату pred, копируются в первый диапазон (начинающийся с result1), а остальные элементы – во второй диапазон (начинающийся с result2). Исходный диапазон не должен перекрываться с выходными диапазонами. Возвращает пару итераторов, определяющих позиции за концами первого и второго полученного диапазона (в указанном порядке).

Сложность линейная (N вызовов pred).








В предположении, что все элементы, удовлетворяющие предикату pred, расположены в начале диапазона [first, last), находит и возвращает позицию первого элемента, не удовлетворяющего предикату pred. Если все элементы диапазона удовлетворяют предикату, то возвращается last.

Сложность логарифмическая (не более log N вызовов pred).








При условии, что диапазон [first, last) является кучей (см. алгоритм make_heap), перемещает первый (наибольший) элемент этой кучи в конец этого диапазона (т. е. в элемент 


(last – 1)) и гарантирует, что элементы, оставшиеся в диапазоне [first, last – 1), образуют кучу. Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность логарифмическая (не более 2


log N сравнений).








Переупорядочивает содержимое диапазона [first, last), создавая предыдущую перестановку из набора лексикографически упорядоченных перестановок элементов данного диапазона. Возвращает true, если перестановка была создана успешно, или false, если исходный диапазон представлял собой первую (в лексикографическом порядке) перестановку; в этом последнем случае генерируется последняя в лексикографическом порядке перестановка (где все элементы расположены в порядке убывания). Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность линейная (не более N/2 перемещений).








При условии, что диапазон [first, last – 1) является кучей (см. алгоритм make_heap), добавляет в эту кучу элемент, расположенный в позиции last – 1, формируя тем самым кучу в диапазоне [first, last). Для сравнения элементов используется предикат comp(


p1, 


p2) или (по умолчанию) операция <.

Сложность логарифмическая (не более log N сравнений).








Случайным образом изменяет порядок элементов из диапазона [first, last). Для генерации случайных чисел по умолчанию используется встроенный генератор с равномерным распределением; может также использоваться явно заданный генератор rand(n), возвращающий целое случайное число в диапазоне [0, n). В стандарте C++11 алгоритм random_shuffle объявлен устаревшим; вместо него рекомендуется использовать алгоритм shuffle.




Конец ознакомительного фрагмента.


Текст предоставлен ООО «ЛитРес».

Прочитайте эту книгу целиком, купив полную легальную версию (https://www.litres.ru/pages/biblio_book/?art=40219365&lfrom=192264536) на ЛитРес.

Безопасно оплатить книгу можно банковской картой Visa, MasterCard, Maestro, со счета мобильного телефона, с платежного терминала, в салоне МТС или Связной, через PayPal, WebMoney, Яндекс.Деньги, QIWI Кошелек, бонусными картами или другим удобным Вам способом.


